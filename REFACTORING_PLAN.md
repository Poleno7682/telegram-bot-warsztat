# Подробный пошаговый план рефакторинга с учетом SOLID принципов

## Дата создания
2024-12-19

## Цели рефакторинга

1. **Устранение дублирования кода** (DRY - Don't Repeat Yourself)
2. **Соблюдение SOLID принципов**
3. **Улучшение производительности** (кэширование)
4. **Повышение поддерживаемости** (единые точки изменений)
5. **Улучшение тестируемости** (разделение ответственности)

---

## SOLID принципы в рефакторинге

### S - Single Responsibility Principle (Принцип единственной ответственности)
- Каждый модуль/класс отвечает за одну задачу
- Утилиты для пользователей, форматирования, валидации - отдельные модули

### O - Open/Closed Principle (Принцип открытости/закрытости)
- Кэширование через декораторы и наследование
- Расширяемость без изменения базового кода

### L - Liskov Substitution Principle (Принцип подстановки Лисков)
- Интерфейсы для сервисов (если понадобятся)
- Консистентное поведение

### I - Interface Segregation Principle (Принцип разделения интерфейса)
- Маленькие, специфичные утилиты
- Не заставлять классы реализовывать ненужные методы

### D - Dependency Inversion Principle (Принцип инверсии зависимостей)
- Зависимость от абстракций (интерфейсов), а не конкретных реализаций
- Использование ServiceFactory для управления зависимостями

---

## ЭТАП 1: Создание базовых утилитных модулей (SRP)

### Шаг 1.1: Создание `app/utils/user_utils.py`
**Цель:** Вынести логику работы с пользователями (SRP)

**Функции:**
- `get_user_language(user: User, fallback: Optional[str] = None) -> str`
- `get_user_or_error(...) -> Tuple[Optional[User], Optional[str]]`

**Зависимости:** 
- `app.models.user.User`
- `app.config.settings.get_settings`

### Шаг 1.2: Создание `app/utils/date_formatter.py`
**Цель:** Единая точка форматирования дат/времени (SRP)

**Класс:** `DateFormatter` (статический класс)
- `format_date(datetime | date, language: str) -> str`
- `format_time(datetime) -> str`
- `format_datetime(datetime, language: str) -> str`

**Зависимости:**
- `app.core.timezone_utils` (будет расширен)

### Шаг 1.3: Расширение `app/core/timezone_utils.py`
**Цель:** Добавить кэширование и удобные хелперы

**Новые функции:**
- `get_local_timezone() -> pytz.BaseTzInfo` (с кэшированием)
- `normalize_to_local(dt: datetime) -> datetime`
- `ensure_timezone_aware(dt: datetime, tz: Optional[pytz.BaseTzInfo]) -> datetime`

**Принцип:** OCP - расширение без изменения существующих функций

---

## ЭТАП 2: Оптимизация TimeService (SRP, DIP)

### Шаг 2.1: Добавление кэширования в TimeService
**Цель:** Устранить множественные запросы к БД

**Изменения:**
- Добавить кэш для настроек (на время жизни экземпляра)
- Добавить кэш для timezone
- Метод `_get_settings()` с кэшированием

**Принцип:** SRP - TimeService отвечает только за временные операции
**Принцип:** DIP - зависимость от абстракции SettingsRepository

### Шаг 2.2: Рефакторинг методов TimeService
**Цель:** Использовать новые утилиты

**Изменения:**
- Использовать `get_local_timezone()` вместо повторяющегося кода
- Использовать `normalize_to_local()` для конвертаций

---

## ЭТАП 3: Создание дополнительных утилит

### Шаг 3.1: Создание `app/utils/booking_utils.py`
**Цель:** Утилиты для работы с бронированиями (SRP)

**Функции:**
- `format_booking_details(booking, language, translate) -> str`
- `filter_future_bookings(bookings: List[Booking]) -> List[Booking]`
- `group_bookings_by_date(bookings: List[Booking]) -> Dict[date, List[Booking]]`

### Шаг 3.2: Создание `app/utils/validators.py`
**Цель:** Валидация данных (SRP)

**Функции:**
- `validate_phone(phone: Optional[str]) -> Tuple[bool, Optional[str]]`
- `validate_telegram_id(telegram_id: str) -> Tuple[bool, Optional[int]]`

### Шаг 3.3: Создание `app/utils/callback_utils.py`
**Цель:** Обработка callback_data (SRP)

**Функции:**
- `parse_callback_data(callback_data: str, prefix: str, index: int) -> Optional[int]`
- `validate_callback_data(callback_data: Optional[str], prefix: str) -> bool`

---

## ЭТАП 4: Рефакторинг handlers

### Шаг 4.1: Рефакторинг `app/bot/handlers/booking.py`
**Изменения:**
- Заменить получение языка на `get_user_language()`
- Заменить форматирование на `DateFormatter`
- Использовать `format_booking_details()`
- Использовать `parse_callback_data()`

**Количество замен:** ~15-20 мест

### Шаг 4.2: Рефакторинг `app/bot/handlers/mechanic.py`
**Изменения:**
- Заменить получение языка
- Заменить форматирование
- Использовать `filter_future_bookings()`
- Использовать `group_bookings_by_date()`

### Шаг 4.3: Рефакторинг `app/bot/handlers/calendar.py`
**Изменения:**
- Заменить получение языка
- Заменить форматирование
- Использовать новые утилиты

### Шаг 4.4: Рефакторинг `app/bot/handlers/common.py`
**Изменения:**
- Использовать `get_user_language()`

---

## ЭТАП 5: Рефакторинг сервисов

### Шаг 5.1: Рефакторинг `app/services/notification_service.py`
**Изменения:**
- Использовать `DateFormatter` вместо `TimeService.format_date/time`
- Использовать `format_booking_details()`

### Шаг 5.2: Рефакторинг `app/services/booking_service.py`
**Изменения:**
- Использовать новые утилиты для timezone
- Оптимизировать получение пользователей

---

## ЭТАП 6: Оптимизация и кэширование

### Шаг 6.1: Расширение ServiceFactory (DIP)
**Цель:** Кэширование экземпляров сервисов

**Изменения:**
- Кэшировать созданные сервисы
- Переиспользовать экземпляры

### Шаг 6.2: Оптимизация SettingsRepository (опционально)
**Цель:** Кэширование настроек на уровне приложения

**Создать:** `app/core/settings_cache.py` (опционально, если нужно)

---

## Порядок выполнения

### Фаза 1: Базовые утилиты (Критично)
1. ✅ Создать `app/utils/user_utils.py`
2. ✅ Расширить `app/core/timezone_utils.py`
3. ✅ Создать `app/utils/date_formatter.py`

### Фаза 2: Оптимизация TimeService (Критично)
4. ✅ Добавить кэширование в TimeService
5. ✅ Рефакторинг методов TimeService

### Фаза 3: Дополнительные утилиты (Важно)
6. ✅ Создать `app/utils/booking_utils.py`
7. ✅ Создать `app/utils/validators.py`
8. ✅ Создать `app/utils/callback_utils.py`

### Фаза 4: Рефакторинг handlers (Важно)
9. ✅ Рефакторинг `booking.py`
10. ✅ Рефакторинг `mechanic.py`
11. ✅ Рефакторинг `calendar.py`
12. ✅ Рефакторинг `common.py`

### Фаза 5: Рефакторинг сервисов (Желательно)
13. ✅ Рефакторинг `notification_service.py`
14. ✅ Рефакторинг `booking_service.py`

### Фаза 6: Оптимизация (Дополнительно)
15. ⏳ Расширение ServiceFactory
16. ⏳ Создание settings_cache (опционально)

---

## Критерии успеха

1. ✅ Все утилиты созданы и протестированы
2. ✅ TimeService оптимизирован (кэширование работает)
3. ✅ Все handlers используют новые утилиты
4. ✅ Нет дублирования кода получения языка
5. ✅ Нет дублирования форматирования
6. ✅ Производительность улучшена (меньше запросов к БД)

---

## Риски и митигация

### Риск 1: Нарушение существующей функциональности
**Митигация:** 
- Поэтапное внедрение
- Тестирование после каждого этапа
- Сохранение обратной совместимости

### Риск 2: Проблемы с кэшированием
**Митигация:**
- Кэш на уровне экземпляра (для сервисов)
- TTL для долгоживущих кэшей
- Возможность принудительного обновления

---

## Тестирование

После каждого этапа:
1. Проверить, что код компилируется
2. Проверить линтер
3. Запустить существующие тесты (если есть)
4. Проверить основную функциональность вручную

---

## Примечания

- Все изменения обратно совместимы
- Старые методы можно оставить как deprecated на некоторое время
- Используем type hints везде
- Добавляем docstrings

---

**Начинаем выполнение!**

